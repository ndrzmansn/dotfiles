{"mode":"editor","version":1,"windowDimensions":{"x":1920,"y":22,"width":1920,"height":1054},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/zwei/Workspace/jython/grammar","buffers":[{"text":"/*\n [The 'BSD licence']\n Copyright (c) 2004 Terence Parr and Loring Craymer\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions\n are met:\n 1. Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n 3. The name of the author may not be used to endorse or promote products\n    derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/** Python 2.3.3 Grammar\n *\n *  Terence Parr and Loring Craymer\n *  February 2004\n *\n *  Converted to ANTLR v3 November 2005 by Terence Parr.\n *\n *  This grammar was derived automatically from the Python 2.3.3\n *  parser grammar to get a syntactically correct ANTLR grammar\n *  for Python.  Then Terence hand tweaked it to be semantically\n *  correct; i.e., removed lookahead issues etc...  It is LL(1)\n *  except for the (sometimes optional) trailing commas and semi-colons.\n *  It needs two symbols of lookahead in this case.\n *\n *  Starting with Loring's preliminary lexer for Python, I modified it\n *  to do my version of the whole nasty INDENT/DEDENT issue just so I\n *  could understand the problem better.  This grammar requires\n *  PythonTokenStream.java to work.  Also I used some rules from the\n *  semi-formal grammar on the web for Python (automatically\n *  translated to ANTLR format by an ANTLR grammar, naturally <grin>).\n *  The lexical rules for python are particularly nasty and it took me\n *  a long time to get it 'right'; i.e., think about it in the proper\n *  way.  Resist changing the lexer unless you've used ANTLR a lot. ;)\n *\n *  I (Terence) tested this by running it on the jython-2.1/Lib\n *  directory of 40k lines of Python.\n *\n *  REQUIRES ANTLR v3\n *\n *\n *  Updated the original parser for Python 2.5 features. The parser has been\n *  altered to produce an AST - the AST work started from tne newcompiler\n *  grammar from Jim Baker.  The current parsing and compiling strategy looks\n *  like this:\n *\n *  Python source->Python.g->AST (org/python/parser/ast/*)->CodeCompiler(ASM)->.class\n */\n\ngrammar Python;\noptions {\n    ASTLabelType=PythonTree;\n    output=AST;\n}\n\ntokens {\n    INDENT;\n    DEDENT;\n    TRAILBACKSLASH; //For dangling backslashes when partial parsing.\n}\n\n@header {\npackage org.python.antlr;\n\nimport org.antlr.runtime.CommonToken;\n\nimport org.python.antlr.ParseException;\nimport org.python.antlr.PythonTree;\nimport org.python.antlr.ast.alias;\nimport org.python.antlr.ast.arguments;\nimport org.python.antlr.ast.Assert;\nimport org.python.antlr.ast.Assign;\nimport org.python.antlr.ast.Attribute;\nimport org.python.antlr.ast.AugAssign;\nimport org.python.antlr.ast.BinOp;\nimport org.python.antlr.ast.BoolOp;\nimport org.python.antlr.ast.boolopType;\nimport org.python.antlr.ast.Break;\nimport org.python.antlr.ast.Call;\nimport org.python.antlr.ast.ClassDef;\nimport org.python.antlr.ast.cmpopType;\nimport org.python.antlr.ast.Compare;\nimport org.python.antlr.ast.comprehension;\nimport org.python.antlr.ast.Context;\nimport org.python.antlr.ast.Continue;\nimport org.python.antlr.ast.Delete;\nimport org.python.antlr.ast.Dict;\nimport org.python.antlr.ast.DictComp;\nimport org.python.antlr.ast.Ellipsis;\nimport org.python.antlr.ast.ErrorMod;\nimport org.python.antlr.ast.ExceptHandler;\nimport org.python.antlr.ast.Exec;\nimport org.python.antlr.ast.Expr;\nimport org.python.antlr.ast.Expression;\nimport org.python.antlr.ast.expr_contextType;\nimport org.python.antlr.ast.ExtSlice;\nimport org.python.antlr.ast.For;\nimport org.python.antlr.ast.GeneratorExp;\nimport org.python.antlr.ast.Global;\nimport org.python.antlr.ast.If;\nimport org.python.antlr.ast.IfExp;\nimport org.python.antlr.ast.Import;\nimport org.python.antlr.ast.ImportFrom;\nimport org.python.antlr.ast.Index;\nimport org.python.antlr.ast.Interactive;\nimport org.python.antlr.ast.keyword;\nimport org.python.antlr.ast.ListComp;\nimport org.python.antlr.ast.Lambda;\nimport org.python.antlr.ast.Module;\nimport org.python.antlr.ast.Name;\nimport org.python.antlr.ast.Num;\nimport org.python.antlr.ast.operatorType;\nimport org.python.antlr.ast.Pass;\nimport org.python.antlr.ast.Print;\nimport org.python.antlr.ast.Raise;\nimport org.python.antlr.ast.Repr;\nimport org.python.antlr.ast.Return;\nimport org.python.antlr.ast.Set;\nimport org.python.antlr.ast.SetComp;\nimport org.python.antlr.ast.Slice;\nimport org.python.antlr.ast.Str;\nimport org.python.antlr.ast.Subscript;\nimport org.python.antlr.ast.TryExcept;\nimport org.python.antlr.ast.TryFinally;\nimport org.python.antlr.ast.Tuple;\nimport org.python.antlr.ast.unaryopType;\nimport org.python.antlr.ast.UnaryOp;\nimport org.python.antlr.ast.While;\nimport org.python.antlr.ast.With;\nimport org.python.antlr.ast.Yield;\nimport org.python.antlr.base.excepthandler;\nimport org.python.antlr.base.expr;\nimport org.python.antlr.base.mod;\nimport org.python.antlr.base.slice;\nimport org.python.antlr.base.stmt;\nimport org.python.core.Py;\nimport org.python.core.PyObject;\nimport org.python.core.PyString;\nimport org.python.core.PyUnicode;\n\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.ListIterator;\n}\n\n@members {\n    private ErrorHandler errorHandler;\n\n    private GrammarActions actions = new GrammarActions();\n\n    private String encoding;\n\n    private boolean printFunction = false;\n    private boolean unicodeLiterals = false;\n\n    public void setErrorHandler(ErrorHandler eh) {\n        this.errorHandler = eh;\n        actions.setErrorHandler(eh);\n    }\n\n    protected Object recoverFromMismatchedToken(IntStream input, int ttype, BitSet follow)\n        throws RecognitionException {\n\n        Object o = errorHandler.recoverFromMismatchedToken(this, input, ttype, follow);\n        if (o != null) {\n            return o;\n        }\n        return super.recoverFromMismatchedToken(input, ttype, follow);\n    }\n\n    public PythonParser(TokenStream input, String encoding) {\n        this(input);\n        this.encoding = encoding;\n    }\n\n    @Override\n    public void reportError(RecognitionException e) {\n      // Update syntax error count and output error.\n      super.reportError(e);\n      errorHandler.reportError(this, e);\n    }\n\n    @Override\n    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {\n        //Do nothing. We will handle error display elsewhere.\n    }\n}\n\n@rulecatch {\ncatch (RecognitionException re) {\n    reportError(re);\n    errorHandler.recover(this, input,re);\n    retval.tree = (PythonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);\n}\n}\n\n@lexer::header {\npackage org.python.antlr;\n}\n\n@lexer::members {\n/** Handles context-sensitive lexing of implicit line joining such as\n *  the case where newline is ignored in cases like this:\n *  a = [3,\n *       4]\n */\nint implicitLineJoiningLevel = 0;\nint startPos=-1;\n\n//For use in partial parsing.\npublic boolean eofWhileNested = false;\npublic boolean partial = false;\npublic boolean single = false;\n\n//If you want to use another error recovery mechanism change this\n//and the same one in the parser.\nprivate ErrorHandler errorHandler;\n\n    public void setErrorHandler(ErrorHandler eh) {\n        this.errorHandler = eh;\n    }\n\n    /**\n     *  Taken directly from antlr's Lexer.java -- needs to be re-integrated every time\n     *  we upgrade from Antlr (need to consider a Lexer subclass, though the issue would\n     *  remain).\n     */\n    public Token nextToken() {\n        startPos = getCharPositionInLine();\n        while (true) {\n            state.token = null;\n            state.channel = Token.DEFAULT_CHANNEL;\n            state.tokenStartCharIndex = input.index();\n            state.tokenStartCharPositionInLine = input.getCharPositionInLine();\n            state.tokenStartLine = input.getLine();\n            state.text = null;\n            if ( input.LA(1)==CharStream.EOF ) {\n                if (implicitLineJoiningLevel > 0) {\n                    eofWhileNested = true;\n                }\n                return Token.EOF_TOKEN;\n            }\n            try {\n                mTokens();\n                if ( state.token==null ) {\n                    emit();\n                }\n                else if ( state.token==Token.SKIP_TOKEN ) {\n                    continue;\n                }\n                return state.token;\n            } catch (NoViableAltException nva) {\n                reportError(nva);\n                errorHandler.recover(this, nva); // throw out current char and try again\n            } catch (FailedPredicateException fp) {\n                //XXX: added this for failed STRINGPART -- the FailedPredicateException\n                //     hides a NoViableAltException.  This should be the only\n                //     FailedPredicateException that gets thrown by the lexer.\n                reportError(fp);\n                errorHandler.recover(this, fp); // throw out current char and try again\n            } catch (RecognitionException re) {\n                reportError(re);\n                // match() routine has already called recover()\n            }\n        }\n    }\n    @Override\n    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {\n        //Do nothing. We will handle error display elsewhere.\n    }\n\n}\n\n//START OF PARSER RULES\n\n//single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\nsingle_input\n@init {\n    mod mtype = null;\n}\n@after {\n    $single_input.tree = mtype;\n}\n    : NEWLINE* EOF\n      {\n        mtype = new Interactive($single_input.start, new ArrayList<stmt>());\n      }\n    | simple_stmt NEWLINE* EOF\n      {\n        mtype = new Interactive($single_input.start, actions.castStmts($simple_stmt.stypes));\n      }\n    | compound_stmt NEWLINE+ EOF\n      {\n        mtype = new Interactive($single_input.start, actions.castStmts($compound_stmt.tree));\n      }\n    ;\n    //XXX: this block is duplicated in three places, how to extract?\n    catch [RecognitionException re] {\n        reportError(re);\n        errorHandler.recover(this, input,re);\n        PythonTree badNode = (PythonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);\n        retval.tree = new ErrorMod(badNode);\n    }\n\n//file_input: (NEWLINE | stmt)* ENDMARKER\nfile_input\n@init {\n    mod mtype = null;\n    List stypes = new ArrayList();\n}\n@after {\n    if (!stypes.isEmpty()) {\n        //The EOF token messes up the end offsets, so set them manually.\n        //XXX: this may no longer be true now that PythonTokenSource is\n        //     adjusting EOF offsets -- but needs testing before I remove\n        //     this.\n        PythonTree stop = (PythonTree)stypes.get(stypes.size() -1);\n        mtype.setCharStopIndex(stop.getCharStopIndex());\n        mtype.setTokenStopIndex(stop.getTokenStopIndex());\n    }\n\n    $file_input.tree = mtype;\n}\n    : (NEWLINE\n      | stmt\n      {\n          if ($stmt.stypes != null) {\n              stypes.addAll($stmt.stypes);\n          }\n      }\n      )* EOF\n         {\n             mtype = new Module($file_input.start, actions.castStmts(stypes));\n         }\n    ;\n    //XXX: this block is duplicated in three places, how to extract?\n    catch [RecognitionException re] {\n        reportError(re);\n        errorHandler.recover(this, input,re);\n        PythonTree badNode = (PythonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);\n        retval.tree = new ErrorMod(badNode);\n    }\n\n//eval_input: testlist NEWLINE* ENDMARKER\neval_input\n@init {\n    mod mtype = null;\n}\n@after {\n    $eval_input.tree = mtype;\n}\n    : LEADING_WS? (NEWLINE)* testlist[expr_contextType.Load] (NEWLINE)* EOF\n      {\n        mtype = new Expression($eval_input.start, actions.castExpr($testlist.tree));\n      }\n    ;\n    //XXX: this block is duplicated in three places, how to extract?\n    catch [RecognitionException re] {\n        reportError(re);\n        errorHandler.recover(this, input,re);\n        PythonTree badNode = (PythonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);\n        retval.tree = new ErrorMod(badNode);\n    }\n\n\n//not in CPython's Grammar file\ndotted_attr\n    returns [expr etype]\n    : n1=NAME\n      ( (DOT n2+=NAME)+\n        {\n            $etype = actions.makeDottedAttr($n1, $n2);\n        }\n      |\n        {\n            $etype = actions.makeNameNode($n1);\n        }\n      )\n    ;\n\n//not in CPython's Grammar file\n// This is used to allow PRINT as a NAME for the __future__ print_function.\nname_or_print\n    returns [Token tok]\n    : NAME {\n        $tok = $name_or_print.start;\n    }\n    | {printFunction}? => PRINT {\n        $tok = $name_or_print.start;\n    }\n    ;\n\n//not in CPython's Grammar file\n//attr is here for Java  compatibility.  A Java foo.getIf() can be called from Jython as foo.if\n//     so we need to support any keyword as an attribute.\n\nattr\n    : NAME\n    | AND\n    | AS\n    | ASSERT\n    | BREAK\n    | CLASS\n    | CONTINUE\n    | DEF\n    | DELETE\n    | ELIF\n    | EXCEPT\n    | EXEC\n    | FINALLY\n    | FROM\n    | FOR\n    | GLOBAL\n    | IF\n    | IMPORT\n    | IN\n    | IS\n    | LAMBDA\n    | NOT\n    | OR\n    | ORELSE\n    | PASS\n    | PRINT\n    | RAISE\n    | RETURN\n    | TRY\n    | WHILE\n    | WITH\n    | YIELD\n    ;\n\n//decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\ndecorator\n    returns [expr etype]\n@after {\n   $decorator.tree = $etype;\n}\n    : AT dotted_attr\n    ( LPAREN\n      ( arglist\n        {\n            $etype = actions.makeCall($LPAREN, $dotted_attr.etype, $arglist.args, $arglist.keywords,\n                     $arglist.starargs, $arglist.kwargs);\n        }\n      |\n        {\n            $etype = actions.makeCall($LPAREN, $dotted_attr.etype);\n        }\n      )\n      RPAREN\n    |\n      {\n          $etype = $dotted_attr.etype;\n      }\n    ) NEWLINE\n    ;\n\n//decorators: decorator+\ndecorators\n    returns [List etypes]\n    : d+=decorator+\n      {\n          $etypes = $d;\n      }\n    ;\n\n//funcdef: [decorators] 'def' NAME parameters ':' suite\nfuncdef\n@init {\n    stmt stype = null;\n}\n\n@after {\n    $funcdef.tree = stype;\n}\n    : decorators? DEF name_or_print parameters COLON suite[false]\n    {\n        Token t = $DEF;\n        if ($decorators.start != null) {\n            t = $decorators.start;\n        }\n        stype = actions.makeFuncdef(t, $name_or_print.start, $parameters.args, $suite.stypes, $decorators.etypes);\n    }\n    ;\n\n//parameters: '(' [varargslist] ')'\nparameters\n    returns [arguments args]\n    : LPAREN\n      (varargslist\n        {\n              $args = $varargslist.args;\n        }\n      |\n        {\n            $args = new arguments($parameters.start, new ArrayList<expr>(), null, null, new ArrayList<expr>());\n        }\n      )\n      RPAREN\n    ;\n\n//not in CPython's Grammar file\ndefparameter\n    [List defaults] returns [expr etype]\n@after {\n   $defparameter.tree = $etype;\n}\n    : fpdef[expr_contextType.Param] (ASSIGN test[expr_contextType.Load])?\n      {\n          $etype = actions.castExpr($fpdef.tree);\n          if ($ASSIGN != null) {\n              defaults.add($test.tree);\n          } else if (!defaults.isEmpty()) {\n              throw new ParseException(\"non-default argument follows default argument\", $fpdef.tree);\n          }\n      }\n    ;\n\n//varargslist: ((fpdef ['=' test] ',')*\n//              ('*' NAME [',' '**' NAME] | '**' NAME) |\n//              fpdef ['=' test] (',' fpdef ['=' test])* [','])\nvarargslist\n    returns [arguments args]\n@init {\n    List defaults = new ArrayList();\n}\n    : d+=defparameter[defaults] (options {greedy=true;}:COMMA d+=defparameter[defaults])*\n      (COMMA\n          (STAR starargs=NAME (COMMA DOUBLESTAR kwargs=NAME)?\n          | DOUBLESTAR kwargs=NAME\n          )?\n      )?\n      {\n          $args = actions.makeArgumentsType($varargslist.start, $d, $starargs, $kwargs, defaults);\n      }\n    | STAR starargs=NAME (COMMA DOUBLESTAR kwargs=NAME)?\n      {\n          $args = actions.makeArgumentsType($varargslist.start, $d, $starargs, $kwargs, defaults);\n      }\n    | DOUBLESTAR kwargs=NAME\n      {\n          $args = actions.makeArgumentsType($varargslist.start, $d, null, $kwargs, defaults);\n      }\n    ;\n\n//fpdef: NAME | '(' fplist ')'\nfpdef[expr_contextType ctype]\n@init {\n    expr etype = null;\n}\n@after {\n    if (etype != null) {\n        $fpdef.tree = etype;\n    }\n    actions.checkAssign(actions.castExpr($fpdef.tree));\n}\n    : NAME\n      {\n          etype = new Name($NAME, $NAME.text, ctype);\n      }\n    | (LPAREN fpdef[null] COMMA) => LPAREN fplist RPAREN\n      {\n          etype = new Tuple($fplist.start, actions.castExprs($fplist.etypes), expr_contextType.Store);\n      }\n    | LPAREN! fplist RPAREN!\n    ;\n\n//fplist: fpdef (',' fpdef)* [',']\nfplist\n    returns [List etypes]\n    : f+=fpdef[expr_contextType.Store]\n      (options {greedy=true;}:COMMA f+=fpdef[expr_contextType.Store])* (COMMA)?\n      {\n          $etypes = $f;\n      }\n    ;\n\n//stmt: simple_stmt | compound_stmt\nstmt\n    returns [List stypes]\n    : simple_stmt\n      {\n          $stypes = $simple_stmt.stypes;\n      }\n    | compound_stmt\n      {\n          $stypes = new ArrayList();\n          $stypes.add($compound_stmt.tree);\n      }\n    ;\n\n//simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\nsimple_stmt\n    returns [List stypes]\n    : s+=small_stmt (options {greedy=true;}:SEMI s+=small_stmt)* (SEMI)? NEWLINE\n      {\n          $stypes = $s;\n      }\n    ;\n\n//small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |\n//             import_stmt | global_stmt | exec_stmt | assert_stmt)\nsmall_stmt : expr_stmt\n           | del_stmt\n           | pass_stmt\n           | flow_stmt\n           | import_stmt\n           | global_stmt\n           | exec_stmt\n           | assert_stmt\n           | {!printFunction}? => print_stmt\n           ;\n\n//expr_stmt: testlist (augassign (yield_expr|testlist) |\n//                     ('=' (yield_expr|testlist))*)\nexpr_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n    if (stype != null) {\n        $expr_stmt.tree = stype;\n    }\n}\n    : ((testlist[null] augassign) => lhs=testlist[expr_contextType.AugStore]\n        ( (aay=augassign y1=yield_expr\n           {\n               actions.checkAugAssign(actions.castExpr($lhs.tree));\n               stype = new AugAssign($lhs.tree, actions.castExpr($lhs.tree), $aay.op, actions.castExpr($y1.etype));\n           }\n          )\n        | (aat=augassign rhs=testlist[expr_contextType.Load]\n           {\n               actions.checkAugAssign(actions.castExpr($lhs.tree));\n               stype = new AugAssign($lhs.tree, actions.castExpr($lhs.tree), $aat.op, actions.castExpr($rhs.tree));\n           }\n          )\n        )\n    | (testlist[null] ASSIGN) => lhs=testlist[expr_contextType.Store]\n        (\n        | ((at=ASSIGN t+=testlist[expr_contextType.Store])+\n            {\n                stype = new Assign($lhs.tree, actions.makeAssignTargets(\n                    actions.castExpr($lhs.tree), $t), actions.makeAssignValue($t));\n            }\n          )\n        | ((ay=ASSIGN y2+=yield_expr)+\n            {\n                stype = new Assign($lhs.start, actions.makeAssignTargets(\n                    actions.castExpr($lhs.tree), $y2), actions.makeAssignValue($y2));\n            }\n          )\n        )\n    | lhs=testlist[expr_contextType.Load]\n      {\n          stype = new Expr($lhs.start, actions.castExpr($lhs.tree));\n      }\n    )\n    ;\n\n//augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n//            '<<=' | '>>=' | '**=' | '//=')\naugassign\n    returns [operatorType op]\n    : PLUSEQUAL\n        {\n            $op = operatorType.Add;\n        }\n    | MINUSEQUAL\n        {\n            $op = operatorType.Sub;\n        }\n    | STAREQUAL\n        {\n            $op = operatorType.Mult;\n        }\n    | SLASHEQUAL\n        {\n            $op = operatorType.Div;\n        }\n    | PERCENTEQUAL\n        {\n            $op = operatorType.Mod;\n        }\n    | AMPEREQUAL\n        {\n            $op = operatorType.BitAnd;\n        }\n    | VBAREQUAL\n        {\n            $op = operatorType.BitOr;\n        }\n    | CIRCUMFLEXEQUAL\n        {\n            $op = operatorType.BitXor;\n        }\n    | LEFTSHIFTEQUAL\n        {\n            $op = operatorType.LShift;\n        }\n    | RIGHTSHIFTEQUAL\n        {\n            $op = operatorType.RShift;\n        }\n    | DOUBLESTAREQUAL\n        {\n            $op = operatorType.Pow;\n        }\n    | DOUBLESLASHEQUAL\n        {\n            $op = operatorType.FloorDiv;\n        }\n    ;\n\n//print_stmt: 'print' ( [ test (',' test)* [','] ] |\n//                      '>>' test [ (',' test)+ [','] ] )\nprint_stmt\n@init {\n    stmt stype = null;\n}\n\n@after {\n    $print_stmt.tree = stype;\n}\n    : PRINT\n      (t1=printlist\n       {\n           stype = new Print($PRINT, null, actions.castExprs($t1.elts), $t1.newline);\n       }\n      | RIGHTSHIFT t2=printlist2\n       {\n           stype = new Print($PRINT, actions.castExpr($t2.elts.get(0)), actions.castExprs($t2.elts, 1), $t2.newline);\n       }\n      |\n       {\n           stype = new Print($PRINT, null, new ArrayList<expr>(), true);\n       }\n      )\n      ;\n\n//not in CPython's Grammar file\nprintlist\n    returns [boolean newline, List elts]\n    : (test[null] COMMA) =>\n       t+=test[expr_contextType.Load] (options {k=2;}: COMMA t+=test[expr_contextType.Load])* (trailcomma=COMMA)?\n       {\n           $elts=$t;\n           if ($trailcomma == null) {\n               $newline = true;\n           } else {\n               $newline = false;\n           }\n       }\n    | t+=test[expr_contextType.Load]\n      {\n          $elts=$t;\n          $newline = true;\n      }\n    ;\n\n//XXX: would be nice if printlist and printlist2 could be merged.\n//not in CPython's Grammar file\nprintlist2\n    returns [boolean newline, List elts]\n    : (test[null] COMMA test[null]) =>\n       t+=test[expr_contextType.Load] (options {k=2;}: COMMA t+=test[expr_contextType.Load])* (trailcomma=COMMA)?\n       { $elts=$t;\n           if ($trailcomma == null) {\n               $newline = true;\n           } else {\n               $newline = false;\n           }\n       }\n    | t+=test[expr_contextType.Load]\n      {\n          $elts=$t;\n          $newline = true;\n      }\n    ;\n\n//del_stmt: 'del' exprlist\ndel_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $del_stmt.tree = stype;\n}\n    : DELETE del_list\n      {\n          stype = new Delete($DELETE, $del_list.etypes);\n      }\n    ;\n\n//pass_stmt: 'pass'\npass_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $pass_stmt.tree = stype;\n}\n    : PASS\n      {\n          stype = new Pass($PASS);\n      }\n    ;\n\n//flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt\nflow_stmt\n    : break_stmt\n    | continue_stmt\n    | return_stmt\n    | raise_stmt\n    | yield_stmt\n    ;\n\n//break_stmt: 'break'\nbreak_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $break_stmt.tree = stype;\n}\n    : BREAK\n      {\n          stype = new Break($BREAK);\n      }\n    ;\n\n//continue_stmt: 'continue'\ncontinue_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $continue_stmt.tree = stype;\n}\n    : CONTINUE\n      {\n          if (!$suite.isEmpty() && $suite::continueIllegal) {\n              errorHandler.error(\"'continue' not supported inside 'finally' clause\", new PythonTree($continue_stmt.start));\n          }\n          stype = new Continue($CONTINUE);\n      }\n    ;\n\n//return_stmt: 'return' [testlist]\nreturn_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $return_stmt.tree = stype;\n}\n    : RETURN\n      (testlist[expr_contextType.Load]\n       {\n           stype = new Return($RETURN, actions.castExpr($testlist.tree));\n       }\n      |\n       {\n           stype = new Return($RETURN, null);\n       }\n      )\n      ;\n\n//yield_stmt: yield_expr\nyield_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $yield_stmt.tree = stype;\n}\n    : yield_expr\n      {\n        stype = new Expr($yield_expr.start, actions.castExpr($yield_expr.etype));\n      }\n    ;\n\n//raise_stmt: 'raise' [test [',' test [',' test]]]\nraise_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $raise_stmt.tree = stype;\n}\n    : RAISE (t1=test[expr_contextType.Load] (COMMA t2=test[expr_contextType.Load]\n        (COMMA t3=test[expr_contextType.Load])?)?)?\n      {\n          stype = new Raise($RAISE, actions.castExpr($t1.tree), actions.castExpr($t2.tree), actions.castExpr($t3.tree));\n      }\n    ;\n\n//import_stmt: import_name | import_from\nimport_stmt\n    : import_name\n    | import_from\n    ;\n\n//import_name: 'import' dotted_as_names\nimport_name\n@init {\n    stmt stype = null;\n}\n@after {\n   $import_name.tree = stype;\n}\n    : IMPORT dotted_as_names\n      {\n          stype = new Import($IMPORT, $dotted_as_names.atypes);\n      }\n    ;\n\n//import_from: ('from' ('.'* dotted_name | '.'+)\n//              'import' ('*' | '(' import_as_names ')' | import_as_names))\nimport_from\n@init {\n    stmt stype = null;\n}\n@after {\n   $import_from.tree = stype;\n}\n    : FROM (d+=DOT* dotted_name | d+=DOT+) IMPORT\n        (STAR\n         {\n             stype = new ImportFrom($FROM, actions.makeFromText($d, $dotted_name.names),\n                 actions.makeModuleNameNode($d, $dotted_name.names),\n                 actions.makeStarAlias($STAR), actions.makeLevel($d));\n         }\n        | i1=import_as_names\n         {\n             String dottedText = $dotted_name.text;\n             if (dottedText != null && dottedText.equals(\"__future__\")) {\n                 List<alias> aliases = $i1.atypes;\n                 for(alias a: aliases) {\n                     if (a != null) {\n                         if (a.getInternalName().equals(\"print_function\")) {\n                             printFunction = true;\n                         } else if (a.getInternalName().equals(\"unicode_literals\")) {\n                             unicodeLiterals = true;\n                         }\n                     }\n                 }\n             }\n             stype = new ImportFrom($FROM, actions.makeFromText($d, $dotted_name.names),\n                 actions.makeModuleNameNode($d, $dotted_name.names),\n                 actions.makeAliases($i1.atypes), actions.makeLevel($d));\n         }\n        | LPAREN i2=import_as_names COMMA? RPAREN\n         {\n             //XXX: this is almost a complete C&P of the code above - is there some way\n             //     to factor it out?\n             String dottedText = $dotted_name.text;\n             if (dottedText != null && dottedText.equals(\"__future__\")) {\n                 List<alias> aliases = $i2.atypes;\n                 for(alias a: aliases) {\n                     if (a != null) {\n                         if (a.getInternalName().equals(\"print_function\")) {\n                             printFunction = true;\n                         } else if (a.getInternalName().equals(\"unicode_literals\")) {\n                             unicodeLiterals = true;\n                         }\n                     }\n                 }\n             }\n             stype = new ImportFrom($FROM, actions.makeFromText($d, $dotted_name.names),\n                 actions.makeModuleNameNode($d, $dotted_name.names),\n                 actions.makeAliases($i2.atypes), actions.makeLevel($d));\n         }\n        )\n    ;\n\n//import_as_names: import_as_name (',' import_as_name)* [',']\nimport_as_names\n    returns [List<alias> atypes]\n    : n+=import_as_name (COMMA! n+=import_as_name)*\n    {\n        $atypes = $n;\n    }\n    ;\n\n//import_as_name: NAME [('as' | NAME) NAME]\nimport_as_name\n    returns [alias atype]\n@after {\n    $import_as_name.tree = $atype;\n}\n    : name=NAME (AS asname=NAME)?\n    {\n        $atype = new alias(actions.makeNameNode($name), actions.makeNameNode($asname));\n    }\n    ;\n\n//XXX: when does CPython Grammar match \"dotted_name NAME NAME\"?\n//dotted_as_name: dotted_name [('as' | NAME) NAME]\ndotted_as_name\n    returns [alias atype]\n@after {\n    $dotted_as_name.tree = $atype;\n}\n    : dotted_name (AS asname=NAME)?\n    {\n        $atype = new alias($dotted_name.names, actions.makeNameNode($asname));\n    }\n    ;\n\n//dotted_as_names: dotted_as_name (',' dotted_as_name)*\ndotted_as_names\n    returns [List<alias> atypes]\n    : d+=dotted_as_name (COMMA! d+=dotted_as_name)*\n    {\n        $atypes = $d;\n    }\n    ;\n\n//dotted_name: NAME ('.' NAME)*\ndotted_name\n    returns [List<Name> names]\n    : NAME (DOT dn+=attr)*\n    {\n        $names = actions.makeDottedName($NAME, $dn);\n    }\n    ;\n\n//global_stmt: 'global' NAME (',' NAME)*\nglobal_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $global_stmt.tree = stype;\n}\n    : GLOBAL n+=NAME (COMMA n+=NAME)*\n      {\n          stype = new Global($GLOBAL, actions.makeNames($n), actions.makeNameNodes($n));\n      }\n    ;\n\n//exec_stmt: 'exec' expr ['in' test [',' test]]\nexec_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $exec_stmt.tree = stype;\n}\n    : EXEC expr[expr_contextType.Load] (IN t1=test[expr_contextType.Load] (COMMA t2=test[expr_contextType.Load])?)?\n      {\n         stype = new Exec($EXEC, actions.castExpr($expr.tree), actions.castExpr($t1.tree), actions.castExpr($t2.tree));\n      }\n    ;\n\n//assert_stmt: 'assert' test [',' test]\nassert_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $assert_stmt.tree = stype;\n}\n    : ASSERT t1=test[expr_contextType.Load] (COMMA t2=test[expr_contextType.Load])?\n      {\n          stype = new Assert($ASSERT, actions.castExpr($t1.tree), actions.castExpr($t2.tree));\n      }\n    ;\n\n//compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\ncompound_stmt\n    : if_stmt\n    | while_stmt\n    | for_stmt\n    | try_stmt\n    | with_stmt\n    | (decorators? DEF) => funcdef\n    | classdef\n    ;\n\n//if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\nif_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $if_stmt.tree = stype;\n}\n    : IF test[expr_contextType.Load] COLON ifsuite=suite[false] elif_clause?\n      {\n          stype = new If($IF, actions.castExpr($test.tree), actions.castStmts($ifsuite.stypes),\n              actions.makeElse($elif_clause.stypes, $elif_clause.tree));\n      }\n    ;\n\n//not in CPython's Grammar file\nelif_clause\n    returns [List stypes]\n@init {\n    stmt stype = null;\n}\n@after {\n   if (stype != null) {\n       $elif_clause.tree = stype;\n   }\n}\n    : else_clause\n      {\n          $stypes = $else_clause.stypes;\n      }\n    | ELIF test[expr_contextType.Load] COLON suite[false]\n      (e2=elif_clause\n       {\n           stype = new If($test.start, actions.castExpr($test.tree), actions.castStmts($suite.stypes), actions.makeElse($e2.stypes, $e2.tree));\n       }\n      |\n       {\n           stype = new If($test.start, actions.castExpr($test.tree), actions.castStmts($suite.stypes), new ArrayList<stmt>());\n       }\n      )\n    ;\n\n//not in CPython's Grammar file\nelse_clause\n    returns [List stypes]\n    : ORELSE COLON elsesuite=suite[false]\n      {\n          $stypes = $suite.stypes;\n      }\n    ;\n\n//while_stmt: 'while' test ':' suite ['else' ':' suite]\nwhile_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $while_stmt.tree = stype;\n}\n    : WHILE test[expr_contextType.Load] COLON s1=suite[false] (ORELSE COLON s2=suite[false])?\n      {\n          stype = actions.makeWhile($WHILE, actions.castExpr($test.tree), $s1.stypes, $s2.stypes);\n      }\n    ;\n\n//for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]\nfor_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $for_stmt.tree = stype;\n}\n    : FOR exprlist[expr_contextType.Store] IN testlist[expr_contextType.Load] COLON s1=suite[false]\n        (ORELSE COLON s2=suite[false])?\n      {\n          stype = actions.makeFor($FOR, $exprlist.etype, actions.castExpr($testlist.tree), $s1.stypes, $s2.stypes);\n      }\n    ;\n\n//try_stmt: ('try' ':' suite\n//           ((except_clause ':' suite)+\n//           ['else' ':' suite]\n//           ['finally' ':' suite] |\n//           'finally' ':' suite))\ntry_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $try_stmt.tree = stype;\n}\n    : TRY COLON trysuite=suite[!$suite.isEmpty() && $suite::continueIllegal]\n      ( e+=except_clause+ (ORELSE COLON elsesuite=suite[!$suite.isEmpty() && $suite::continueIllegal])? (FINALLY COLON finalsuite=suite[true])?\n        {\n            stype = actions.makeTryExcept($TRY, $trysuite.stypes, $e, $elsesuite.stypes, $finalsuite.stypes);\n        }\n      | FINALLY COLON finalsuite=suite[true]\n        {\n            stype = actions.makeTryFinally($TRY, $trysuite.stypes, $finalsuite.stypes);\n        }\n      )\n      ;\n\n//with_stmt: 'with' with_item (',' with_item)*  ':' suite\nwith_stmt\n@init {\n    stmt stype = null;\n}\n@after {\n   $with_stmt.tree = stype;\n}\n    : WITH w+=with_item (options {greedy=true;}:COMMA w+=with_item)* COLON suite[false]\n      {\n          stype = actions.makeWith($WITH, $w, $suite.stypes);\n      }\n    ;\n\n//with_item: test ['as' expr]\nwith_item\n@init {\n    stmt stype = null;\n}\n@after {\n   $with_item.tree = stype;\n}\n    : test[expr_contextType.Load] (AS expr[expr_contextType.Store])?\n      {\n          expr item = actions.castExpr($test.tree);\n          expr var = null;\n          if ($expr.start != null) {\n              var = actions.castExpr($expr.tree);\n              actions.checkAssign(var);\n          }\n          stype = new With($test.start, item, var, null);\n      }\n    ;\n\n//except_clause: 'except' [test [('as' | ',') test]]\nexcept_clause\n@init {\n    excepthandler extype = null;\n}\n@after {\n   $except_clause.tree = extype;\n}\n    : EXCEPT (t1=test[expr_contextType.Load] ((COMMA | AS) t2=test[expr_contextType.Store])?)? COLON suite[!$suite.isEmpty() && $suite::continueIllegal]\n      {\n          extype = new ExceptHandler($EXCEPT, actions.castExpr($t1.tree), actions.castExpr($t2.tree),\n              actions.castStmts($suite.stypes));\n      }\n    ;\n\n//suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT\nsuite\n    [boolean fromFinally] returns [List stypes]\nscope {\n    boolean continueIllegal;\n}\n@init {\n    if ($suite::continueIllegal || fromFinally) {\n        $suite::continueIllegal = true;\n    } else {\n        $suite::continueIllegal = false;\n    }\n    $stypes = new ArrayList();\n}\n    : simple_stmt\n      {\n          $stypes = $simple_stmt.stypes;\n      }\n    | NEWLINE INDENT\n      (stmt\n       {\n           if ($stmt.stypes != null) {\n               $stypes.addAll($stmt.stypes);\n           }\n       }\n      )+ DEDENT\n    ;\n\n//test: or_test ['if' or_test 'else' test] | lambdef\ntest[expr_contextType ctype]\n@init {\n    expr etype = null;\n}\n@after {\n   if (etype != null) {\n       $test.tree = etype;\n   }\n}\n    :o1=or_test[ctype]\n      ( (IF or_test[null] ORELSE) => IF o2=or_test[ctype] ORELSE e=test[expr_contextType.Load]\n         {\n             etype = new IfExp($o1.start, actions.castExpr($o2.tree), actions.castExpr($o1.tree), actions.castExpr($e.tree));\n         }\n      |\n     -> or_test\n      )\n    | lambdef\n    ;\n\n//or_test: and_test ('or' and_test)*\nor_test\n    [expr_contextType ctype] returns [Token leftTok]\n@after {\n    if ($or != null) {\n        Token tok = $left.start;\n        if ($left.leftTok != null) {\n            tok = $left.leftTok;\n        }\n        $or_test.tree = actions.makeBoolOp(tok, $left.tree, boolopType.Or, $right);\n    }\n}\n    : left=and_test[ctype]\n        ( (or=OR right+=and_test[ctype]\n          )+\n        |\n       -> $left\n        )\n    ;\n\n//and_test: not_test ('and' not_test)*\nand_test\n    [expr_contextType ctype] returns [Token leftTok]\n@after {\n    if ($and != null) {\n        Token tok = $left.start;\n        if ($left.leftTok != null) {\n            tok = $left.leftTok;\n        }\n        $and_test.tree = actions.makeBoolOp(tok, $left.tree, boolopType.And, $right);\n    }\n}\n    : left=not_test[ctype]\n        ( (and=AND right+=not_test[ctype]\n          )+\n        |\n       -> $left\n        )\n    ;\n\n//not_test: 'not' not_test | comparison\nnot_test\n    [expr_contextType ctype] returns [Token leftTok]\n@init {\n    expr etype = null;\n}\n@after {\n   if (etype != null) {\n       $not_test.tree = etype;\n   }\n}\n    : NOT nt=not_test[ctype]\n      {\n          etype = new UnaryOp($NOT, unaryopType.Not, actions.castExpr($nt.tree));\n      }\n    | comparison[ctype]\n      {\n          $leftTok = $comparison.leftTok;\n      }\n    ;\n\n//comparison: expr (comp_op expr)*\ncomparison\n    [expr_contextType ctype] returns [Token leftTok]\n@init {\n    List cmps = new ArrayList();\n}\n@after {\n    $leftTok = $left.leftTok;\n    if (!cmps.isEmpty()) {\n        $comparison.tree = new Compare($left.start, actions.castExpr($left.tree), actions.makeCmpOps(cmps),\n            actions.castExprs($right));\n    }\n}\n    : left=expr[ctype]\n       ( ( comp_op right+=expr[ctype]\n           {\n               cmps.add($comp_op.op);\n           }\n         )+\n       |\n      -> $left\n       )\n    ;\n\n//comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\ncomp_op\n    returns [cmpopType op]\n    : LESS\n      {\n          $op = cmpopType.Lt;\n      }\n    | GREATER\n      {\n          $op = cmpopType.Gt;\n      }\n    | EQUAL\n      {\n          $op = cmpopType.Eq;\n      }\n    | GREATEREQUAL\n      {\n          $op = cmpopType.GtE;\n      }\n    | LESSEQUAL\n      {\n          $op = cmpopType.LtE;\n      }\n    | ALT_NOTEQUAL\n      {\n          $op = cmpopType.NotEq;\n      }\n    | NOTEQUAL\n      {\n          $op = cmpopType.NotEq;\n      }\n    | IN\n      {\n          $op = cmpopType.In;\n      }\n    | NOT IN\n      {\n          $op = cmpopType.NotIn;\n      }\n    | IS\n      {\n          $op = cmpopType.Is;\n      }\n    | IS NOT\n      {\n          $op = cmpopType.IsNot;\n      }\n    ;\n\n//expr: xor_expr ('|' xor_expr)*\nexpr\n    [expr_contextType ect] returns [Token leftTok]\nscope {\n    expr_contextType ctype;\n}\n@init {\n    $expr::ctype = ect;\n}\n@after {\n    $leftTok = $left.lparen;\n    if ($op != null) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $expr.tree = actions.makeBinOp(tok, $left.tree, operatorType.BitOr, $right);\n    }\n}\n    : left=xor_expr\n        ( (op=VBAR right+=xor_expr\n          )+\n        |\n       -> $left\n        )\n    ;\n\n\n//xor_expr: and_expr ('^' and_expr)*\nxor_expr\n    returns [Token lparen = null]\n@after {\n    if ($op != null) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $xor_expr.tree = actions.makeBinOp(tok, $left.tree, operatorType.BitXor, $right);\n    }\n    $lparen = $left.lparen;\n}\n    : left=and_expr\n        ( (op=CIRCUMFLEX right+=and_expr\n          )+\n        |\n       -> $left\n        )\n    ;\n\n//and_expr: shift_expr ('&' shift_expr)*\nand_expr\n    returns [Token lparen = null]\n@after {\n    if ($op != null) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $and_expr.tree = actions.makeBinOp(tok, $left.tree, operatorType.BitAnd, $right);\n    }\n    $lparen = $left.lparen;\n}\n    : left=shift_expr\n        ( (op=AMPER right+=shift_expr\n          )+\n        |\n       -> $left\n        )\n    ;\n\n//shift_expr: arith_expr (('<<'|'>>') arith_expr)*\nshift_expr\n    returns [Token lparen = null]\n@init {\n    List ops = new ArrayList();\n    List toks = new ArrayList();\n}\n@after {\n    if (!ops.isEmpty()) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $shift_expr.tree = actions.makeBinOp(tok, $left.tree, ops, $right, toks);\n    }\n    $lparen = $left.lparen;\n}\n    : left=arith_expr\n        ( ( shift_op right+=arith_expr\n            {\n                ops.add($shift_op.op);\n                toks.add($shift_op.start);\n            }\n          )+\n        |\n       -> $left\n        )\n    ;\n\nshift_op\n    returns [operatorType op]\n    : LEFTSHIFT\n      {\n          $op = operatorType.LShift;\n      }\n    | RIGHTSHIFT\n      {\n          $op = operatorType.RShift;\n      }\n    ;\n\n//arith_expr: term (('+'|'-') term)*\narith_expr\n    returns [Token lparen = null]\n@init {\n    List ops = new ArrayList();\n    List toks = new ArrayList();\n}\n@after {\n    if (!ops.isEmpty()) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $arith_expr.tree = actions.makeBinOp(tok, $left.tree, ops, $right, toks);\n    }\n    $lparen = $left.lparen;\n}\n    : left=term\n        ( (arith_op right+=term\n           {\n               ops.add($arith_op.op);\n               toks.add($arith_op.start);\n           }\n          )+\n        |\n       -> $left\n        )\n    ;\n    // This only happens when Antlr is allowed to do error recovery (for example if ListErrorHandler\n    // is used.  It is at least possible that this is a bug in Antlr itself, so this needs further\n    // investigation.  To reproduce, set errorHandler to ListErrorHandler and try to parse \"[\".\n    catch [RewriteCardinalityException rce] {\n        PythonTree badNode = (PythonTree)adaptor.errorNode(input, retval.start, input.LT(-1), null);\n        retval.tree = badNode;\n        errorHandler.error(\"Internal Parser Error\", badNode);\n    }\n\narith_op\n    returns [operatorType op]\n    : PLUS\n      {\n          $op = operatorType.Add;\n      }\n    | MINUS\n      {\n          $op = operatorType.Sub;\n      }\n    ;\n\n//term: factor (('*'|'/'|'%'|'//') factor)*\nterm\n    returns [Token lparen = null]\n@init {\n    List ops = new ArrayList();\n    List toks = new ArrayList();\n}\n@after {\n    $lparen = $left.lparen;\n    if (!ops.isEmpty()) {\n        Token tok = $left.start;\n        if ($left.lparen != null) {\n            tok = $left.lparen;\n        }\n        $term.tree = actions.makeBinOp(tok, $left.tree, ops, $right, toks);\n    }\n}\n    : left=factor\n        ( (term_op right+=factor\n          {\n              ops.add($term_op.op);\n              toks.add($term_op.start);\n          }\n          )+\n        |\n       -> $left\n        )\n    ;\n\nterm_op\n    returns [operatorType op]\n    : STAR\n      {\n          $op = operatorType.Mult;\n      }\n    | SLASH\n      {\n          $op = operatorType.Div;\n      }\n    | PERCENT\n      {\n          $op = operatorType.Mod;\n      }\n    | DOUBLESLASH\n      {\n          $op = operatorType.FloorDiv;\n      }\n    ;\n\n//factor: ('+'|'-'|'~') factor | power\nfactor\n    returns [expr etype, Token lparen = null]\n@after {\n    $factor.tree = $etype;\n}\n    : PLUS p=factor\n      {\n          $etype = new UnaryOp($PLUS, unaryopType.UAdd, $p.etype);\n      }\n    | MINUS m=factor\n      {\n          $etype = actions.negate($MINUS, $m.etype);\n      }\n    | TILDE t=factor\n      {\n          $etype = new UnaryOp($TILDE, unaryopType.Invert, $t.etype);\n      }\n    | power\n      {\n          $etype = actions.castExpr($power.tree);\n          $lparen = $power.lparen;\n      }\n    ;\n\n//power: atom trailer* ['**' factor]\npower\n    returns [expr etype, Token lparen = null]\n@after {\n    $power.tree = $etype;\n}\n    : atom (t+=trailer[$atom.start, $atom.tree])* (options {greedy=true;}:d=DOUBLESTAR factor)?\n      {\n          $lparen = $atom.lparen;\n          //XXX: This could be better.\n          $etype = actions.castExpr($atom.tree);\n          if ($t != null) {\n              for(Object o : $t) {\n                  actions.recurseSetContext($etype, expr_contextType.Load);\n                  if (o instanceof Call) {\n                      Call c = (Call)o;\n                      c.setFunc((PyObject)$etype);\n                      $etype = c;\n                  } else if (o instanceof Subscript) {\n                      Subscript c = (Subscript)o;\n                      c.setValue((PyObject)$etype);\n                      $etype = c;\n                  } else if (o instanceof Attribute) {\n                      Attribute c = (Attribute)o;\n                      c.setCharStartIndex($etype.getCharStartIndex());\n                      c.setValue((PyObject)$etype);\n                      $etype = c;\n                  }\n              }\n          }\n          if ($d != null) {\n              List right = new ArrayList();\n              right.add($factor.tree);\n              $etype = actions.makeBinOp($atom.start, $etype, operatorType.Pow, right);\n          }\n      }\n    ;\n\n//atom: ('(' [yield_expr|testlist_gexp] ')' |\n//       '[' [listmaker] ']' |\n//       '{' [dictorsetmaker] '}' |\n//       '`' testlist1 '`' |\n//       NAME | NUMBER | STRING+)\natom\n    returns [Token lparen = null]\n@init {\n    expr etype = null;\n}\n@after {\n   if (etype != null) {\n       $atom.tree = etype;\n   }\n}\n    : LPAREN\n      {\n          $lparen = $LPAREN;\n      }\n      ( yield_expr\n        {\n            etype = $yield_expr.etype;\n        }\n      | testlist_gexp\n     -> testlist_gexp\n      |\n        {\n            etype = new Tuple($LPAREN, new ArrayList<expr>(), $expr::ctype);\n        }\n      )\n      RPAREN\n    | LBRACK\n      (listmaker[$LBRACK]\n     -> listmaker\n      |\n       {\n           etype = new org.python.antlr.ast.List($LBRACK, new ArrayList<expr>(), $expr::ctype);\n       }\n      )\n      RBRACK\n    | LCURLY\n       (dictorsetmaker[$LCURLY]\n      -> dictorsetmaker\n       |\n        {\n            etype = new Dict($LCURLY, new ArrayList<expr>(), new ArrayList<expr>());\n        }\n       )\n       RCURLY\n     | lb=BACKQUOTE testlist[expr_contextType.Load] rb=BACKQUOTE\n       {\n           etype = new Repr($lb, actions.castExpr($testlist.tree));\n       }\n     | name_or_print\n       {\n           etype = new Name($name_or_print.start, $name_or_print.text, $expr::ctype);\n       }\n     | INT\n       {\n           etype = new Num($INT, actions.makeInt($INT));\n       }\n     | LONGINT\n       {\n           etype = new Num($LONGINT, actions.makeInt($LONGINT));\n       }\n     | FLOAT\n       {\n           etype = new Num($FLOAT, actions.makeFloat($FLOAT));\n       }\n     | COMPLEX\n       {\n           etype = new Num($COMPLEX, actions.makeComplex($COMPLEX));\n       }\n     | (S+=STRING)+\n       {\n           etype = new Str(actions.extractStringToken($S), actions.extractStrings($S, encoding, unicodeLiterals));\n       }\n     ;\n\n//listmaker: test ( list_for | (',' test)* [','] )\nlistmaker[Token lbrack]\n@init {\n    List gens = new ArrayList();\n    expr etype = null;\n}\n@after {\n   $listmaker.tree = etype;\n}\n    : t+=test[$expr::ctype]\n        (list_for[gens]\n         {\n             Collections.reverse(gens);\n             List<comprehension> c = gens;\n             etype = new ListComp($listmaker.start, actions.castExpr($t.get(0)), c);\n         }\n        | (options {greedy=true;}:COMMA t+=test[$expr::ctype])*\n           {\n               etype = new org.python.antlr.ast.List($lbrack, actions.castExprs($t), $expr::ctype);\n           }\n        ) (COMMA)?\n    ;\n\n//testlist_gexp: test ( comp_for | (',' test)* [','] )\ntestlist_gexp\n@init {\n    expr etype = null;\n    List gens = new ArrayList();\n}\n@after {\n    if (etype != null) {\n        $testlist_gexp.tree = etype;\n    }\n}\n    : t+=test[$expr::ctype]\n        ( (options {k=2;}: c1=COMMA t+=test[$expr::ctype])* (c2=COMMA)?\n         { $c1 != null || $c2 != null }? \n           {\n               etype = new Tuple($testlist_gexp.start, actions.castExprs($t), $expr::ctype);\n           }\n        | -> test\n        | (comp_for[gens]\n           {\n               Collections.reverse(gens);\n               List<comprehension> c = gens;\n               expr e = actions.castExpr($t.get(0));\n               if (e instanceof Context) {\n                   ((Context)e).setContext(expr_contextType.Load);\n               }\n               etype = new GeneratorExp($testlist_gexp.start, actions.castExpr($t.get(0)), c);\n           }\n          )\n        )\n    ;\n\n//lambdef: 'lambda' [varargslist] ':' test\nlambdef\n@init {\n    expr etype = null;\n}\n@after {\n    $lambdef.tree = etype;\n}\n    : LAMBDA (varargslist)? COLON test[expr_contextType.Load]\n      {\n          arguments a = $varargslist.args;\n          if (a == null) {\n              a = new arguments($LAMBDA, new ArrayList<expr>(), null, null, new ArrayList<expr>());\n          }\n          etype = new Lambda($LAMBDA, a, actions.castExpr($test.tree));\n      }\n    ;\n\n//trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\ntrailer [Token begin, PythonTree ptree]\n@init {\n    expr etype = null;\n}\n@after {\n    if (etype != null) {\n        $trailer.tree = etype;\n    }\n}\n    : LPAREN\n      (arglist\n       {\n           etype = new Call($begin, actions.castExpr($ptree), actions.castExprs($arglist.args),\n             actions.makeKeywords($arglist.keywords), $arglist.starargs, $arglist.kwargs);\n       }\n      |\n       {\n           etype = new Call($begin, actions.castExpr($ptree), new ArrayList<expr>(), new ArrayList<keyword>(), null, null);\n       }\n      )\n      RPAREN\n    | LBRACK subscriptlist[$begin] RBRACK\n      {\n          etype = new Subscript($begin, actions.castExpr($ptree), actions.castSlice($subscriptlist.tree), $expr::ctype);\n      }\n    | DOT attr\n      {\n          etype = new Attribute($begin, actions.castExpr($ptree), new Name($attr.tree, $attr.text, expr_contextType.Load), $expr::ctype);\n      }\n    ;\n\n//subscriptlist: subscript (',' subscript)* [',']\nsubscriptlist[Token begin]\n@init {\n    slice sltype = null;\n}\n@after {\n   $subscriptlist.tree = sltype;\n}\n    : sub+=subscript (options {greedy=true;}:c1=COMMA sub+=subscript)* (c2=COMMA)?\n      {\n          sltype = actions.makeSliceType($begin, $c1, $c2, $sub);\n      }\n    ;\n\n//subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\nsubscript\n    returns [slice sltype]\n@after {\n    $subscript.tree = $sltype;\n}\n    : d1=DOT DOT DOT\n      {\n          $sltype = new Ellipsis($d1);\n      }\n    | (test[null] COLON)\n   => lower=test[expr_contextType.Load] (c1=COLON (upper1=test[expr_contextType.Load])? (sliceop)?)?\n      {\n          $sltype = actions.makeSubscript($lower.tree, $c1, $upper1.tree, $sliceop.tree);\n      }\n    | (COLON)\n   => c2=COLON (upper2=test[expr_contextType.Load])? (sliceop)?\n      {\n          $sltype = actions.makeSubscript(null, $c2, $upper2.tree, $sliceop.tree);\n      }\n    | test[expr_contextType.Load]\n      {\n          $sltype = new Index($test.start, actions.castExpr($test.tree));\n      }\n    ;\n\n//sliceop: ':' [test]\nsliceop\n@init {\n    expr etype = null;\n}\n@after {\n    if (etype != null) {\n        $sliceop.tree = etype;\n    }\n}\n    : COLON\n     (test[expr_contextType.Load]\n    -> test\n     |\n       {\n           etype = new Name($COLON, \"None\", expr_contextType.Load);\n       }\n     )\n    ;\n\n//exprlist: expr (',' expr)* [',']\nexprlist\n    [expr_contextType ctype] returns [expr etype]\n    : (expr[null] COMMA) => e+=expr[ctype] (options {k=2;}: COMMA e+=expr[ctype])* (COMMA)?\n       {\n           $etype = new Tuple($exprlist.start, actions.castExprs($e), ctype);\n       }\n    | expr[ctype]\n      {\n        $etype = actions.castExpr($expr.tree);\n      }\n    ;\n\n//not in CPython's Grammar file\n//Needed as an exprlist that does not produce tuples for del_stmt.\ndel_list\n    returns [List<expr> etypes]\n    : e+=expr[expr_contextType.Del] (options {k=2;}: COMMA e+=expr[expr_contextType.Del])* (COMMA)?\n      {\n          $etypes = actions.makeDeleteList($e);\n      }\n    ;\n\n//testlist: test (',' test)* [',']\ntestlist[expr_contextType ctype]\n@init {\n    expr etype = null;\n}\n@after {\n    if (etype != null) {\n        $testlist.tree = etype;\n    }\n}\n    : (test[null] COMMA)\n   => t+=test[ctype] (options {k=2;}: COMMA t+=test[ctype])* (COMMA)?\n      {\n          etype = new Tuple($testlist.start, actions.castExprs($t), ctype);\n      }\n    | test[ctype]\n    ;\n\n//dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |\n//                  (test (comp_for | (',' test)* [','])) )\n\n//dictmaker: test ':' test (',' test ':' test)* [',']\ndictorsetmaker[Token lcurly]\n@init {\n    List gens = new ArrayList();\n    expr etype = null;\n}\n@after {\n    if (etype != null) {\n        $dictorsetmaker.tree = etype;\n    }\n}\n    : k+=test[expr_contextType.Load]\n         (\n             (COLON v+=test[expr_contextType.Load]\n               ( comp_for[gens]\n                 {\n                     Collections.reverse(gens);\n                     List<comprehension> c = gens;\n                     etype = new DictComp($dictorsetmaker.start, actions.castExpr($k.get(0)), actions.castExpr($v.get(0)), c);\n                 }\n               | (options {k=2;}:COMMA k+=test[expr_contextType.Load] COLON v+=test[expr_contextType.Load])*\n                 {\n                     etype = new Dict($lcurly, actions.castExprs($k), actions.castExprs($v));\n                 }\n               )\n             |(COMMA k+=test[expr_contextType.Load])*\n              {\n                  etype = new Set($lcurly, actions.castExprs($k));\n              }\n             )\n             (COMMA)?\n         | comp_for[gens]\n           {\n               Collections.reverse(gens);\n               List<comprehension> c = gens;\n               expr e = actions.castExpr($k.get(0));\n               if (e instanceof Context) {\n                   ((Context)e).setContext(expr_contextType.Load);\n               }\n               etype = new SetComp($lcurly, actions.castExpr($k.get(0)), c);\n           }\n         )\n    ;\n\n//classdef: 'class' NAME ['(' [testlist] ')'] ':' suite\nclassdef\n@init {\n    stmt stype = null;\n}\n@after {\n   $classdef.tree = stype;\n}\n    : decorators? CLASS NAME (LPAREN testlist[expr_contextType.Load]? RPAREN)? COLON suite[false]\n      {\n          Token t = $CLASS;\n          if ($decorators.start != null) {\n              t = $decorators.start;\n          }\n          stype = new ClassDef(t, actions.cantBeNoneName($NAME),\n              actions.makeBases(actions.castExpr($testlist.tree)),\n              actions.castStmts($suite.stypes),\n              actions.castExprs($decorators.etypes));\n      }\n    ;\n\n//arglist: (argument ',')* (argument [',']\n//                         |'*' test (',' argument)* [',' '**' test]\n//                         |'**' test)\narglist\n    returns [List args, List keywords, expr starargs, expr kwargs]\n@init {\n    List arguments = new ArrayList();\n    List kws = new ArrayList();\n    List gens = new ArrayList();\n}\n    : argument[arguments, kws, gens, true, false] (COMMA argument[arguments, kws, gens, false, false])*\n          (COMMA\n              ( STAR s=test[expr_contextType.Load] (COMMA argument[arguments, kws, gens, false, true])* (COMMA DOUBLESTAR k=test[expr_contextType.Load])?\n              | DOUBLESTAR k=test[expr_contextType.Load]\n              )?\n          )?\n      {\n          if (arguments.size() > 1 && gens.size() > 0) {\n              actions.errorGenExpNotSoleArg(new PythonTree($arglist.start));\n          }\n          $args=arguments;\n          $keywords=kws;\n          $starargs=actions.castExpr($s.tree);\n          $kwargs=actions.castExpr($k.tree);\n      }\n    | STAR s=test[expr_contextType.Load] (COMMA argument[arguments, kws, gens, false, true])* (COMMA DOUBLESTAR k=test[expr_contextType.Load])?\n      {\n          $starargs=actions.castExpr($s.tree);\n          $keywords=kws;\n          $kwargs=actions.castExpr($k.tree);\n      }\n    | DOUBLESTAR k=test[expr_contextType.Load]\n      {\n          $kwargs=actions.castExpr($k.tree);\n      }\n    ;\n\n//argument: test [comp_for] | test '=' test  # Really [keyword '='] test\nargument\n    [List arguments, List kws, List gens, boolean first, boolean afterStar] returns [boolean genarg]\n    : t1=test[expr_contextType.Load]\n        ((ASSIGN t2=test[expr_contextType.Load])\n          {\n              expr newkey = actions.castExpr($t1.tree);\n              //Loop through all current keys and fail on duplicate.\n              for(Object o: $kws) {\n                  List list = (List)o;\n                  Object oldkey = list.get(0);\n                  if (oldkey instanceof Name && newkey instanceof Name) {\n                      if (((Name)oldkey).getId().equals(((Name)newkey).getId())) {\n                          errorHandler.error(\"keyword arguments repeated\", $t1.tree);\n                      }\n                  }\n              }\n              List<expr> exprs = new ArrayList<expr>();\n              exprs.add(newkey);\n              exprs.add(actions.castExpr($t2.tree));\n              $kws.add(exprs);\n          }\n        | comp_for[$gens]\n          {\n              if (!first) {\n                  actions.errorGenExpNotSoleArg($comp_for.tree);\n              }\n              $genarg = true;\n              Collections.reverse($gens);\n              List<comprehension> c = $gens;\n              arguments.add(new GeneratorExp($t1.start, actions.castExpr($t1.tree), c));\n          }\n        |\n          {\n              if (kws.size() > 0) {\n                  errorHandler.error(\"non-keyword arg after keyword arg\", $t1.tree);\n              } else if (afterStar) {\n                  errorHandler.error(\"only named arguments may follow *expression\", $t1.tree);\n              }\n              $arguments.add($t1.tree);\n          }\n        )\n    ;\n\n//list_iter: list_for | list_if\nlist_iter [List gens, List ifs]\n    : list_for[gens]\n    | list_if[gens, ifs]\n    ;\n\n//list_for: 'for' exprlist 'in' testlist_safe [list_iter]\nlist_for [List gens]\n@init {\n    List ifs = new ArrayList();\n}\n    : FOR exprlist[expr_contextType.Store] IN testlist[expr_contextType.Load] (list_iter[gens, ifs])?\n      {\n          Collections.reverse(ifs);\n          gens.add(new comprehension($FOR, $exprlist.etype, actions.castExpr($testlist.tree), ifs));\n      }\n    ;\n\n//list_if: 'if' test [list_iter]\nlist_if[List gens, List ifs]\n    : IF test[expr_contextType.Load] (list_iter[gens, ifs])?\n      {\n        ifs.add(actions.castExpr($test.tree));\n      }\n    ;\n\n//comp_iter: comp_for | comp_if\ncomp_iter [List gens, List ifs]\n    : comp_for[gens]\n    | comp_if[gens, ifs]\n    ;\n\n//comp_for: 'for' exprlist 'in' or_test [comp_iter]\ncomp_for [List gens]\n@init {\n    List ifs = new ArrayList();\n}\n    : FOR exprlist[expr_contextType.Store] IN or_test[expr_contextType.Load] comp_iter[gens, ifs]?\n      {\n          Collections.reverse(ifs);\n          gens.add(new comprehension($FOR, $exprlist.etype, actions.castExpr($or_test.tree), ifs));\n      }\n    ;\n\n//comp_if: 'if' old_test [comp_iter]\ncomp_if[List gens, List ifs]\n    : IF test[expr_contextType.Load] comp_iter[gens, ifs]?\n      {\n        ifs.add(actions.castExpr($test.tree));\n      }\n    ;\n\n//yield_expr: 'yield' [testlist]\nyield_expr\n    returns [expr etype]\n@after {\n    //needed for y2+=yield_expr\n    $yield_expr.tree = $etype;\n}\n    : YIELD testlist[expr_contextType.Load]?\n      {\n          $etype = new Yield($YIELD, actions.castExpr($testlist.tree));\n      }\n    ;\n\n//START OF LEXER RULES\nAS        : 'as' ;\nASSERT    : 'assert' ;\nBREAK     : 'break' ;\nCLASS     : 'class' ;\nCONTINUE  : 'continue' ;\nDEF       : 'def' ;\nDELETE    : 'del' ;\nELIF      : 'elif' ;\nEXCEPT    : 'except' ;\nEXEC      : 'exec' ;\nFINALLY   : 'finally' ;\nFROM      : 'from' ;\nFOR       : 'for' ;\nGLOBAL    : 'global' ;\nIF        : 'if' ;\nIMPORT    : 'import' ;\nIN        : 'in' ;\nIS        : 'is' ;\nLAMBDA    : 'lambda' ;\nORELSE    : 'else' ;\nPASS      : 'pass'  ;\nPRINT     : 'print' ;\nRAISE     : 'raise' ;\nRETURN    : 'return' ;\nTRY       : 'try' ;\nWHILE     : 'while' ;\nWITH      : 'with' ;\nYIELD     : 'yield' ;\n\nLPAREN    : '(' {implicitLineJoiningLevel++;} ;\n\nRPAREN    : ')' {implicitLineJoiningLevel--;} ;\n\nLBRACK    : '[' {implicitLineJoiningLevel++;} ;\n\nRBRACK    : ']' {implicitLineJoiningLevel--;} ;\n\nCOLON     : ':' ;\n\nCOMMA    : ',' ;\n\nSEMI    : ';' ;\n\nPLUS    : '+' ;\n\nMINUS    : '-' ;\n\nSTAR    : '*' ;\n\nSLASH    : '/' ;\n\nVBAR    : '|' ;\n\nAMPER    : '&' ;\n\nLESS    : '<' ;\n\nGREATER    : '>' ;\n\nASSIGN    : '=' ;\n\nPERCENT    : '%' ;\n\nBACKQUOTE    : '`' ;\n\nLCURLY    : '{' {implicitLineJoiningLevel++;} ;\n\nRCURLY    : '}' {implicitLineJoiningLevel--;} ;\n\nCIRCUMFLEX    : '^' ;\n\nTILDE    : '~' ;\n\nEQUAL    : '==' ;\n\nNOTEQUAL    : '!=' ;\n\nALT_NOTEQUAL: '<>' ;\n\nLESSEQUAL    : '<=' ;\n\nLEFTSHIFT    : '<<' ;\n\nGREATEREQUAL    : '>=' ;\n\nRIGHTSHIFT    : '>>' ;\n\nPLUSEQUAL    : '+=' ;\n\nMINUSEQUAL    : '-=' ;\n\nDOUBLESTAR    : '**' ;\n\nSTAREQUAL    : '*=' ;\n\nDOUBLESLASH    : '//' ;\n\nSLASHEQUAL    : '/=' ;\n\nVBAREQUAL    : '|=' ;\n\nPERCENTEQUAL    : '%=' ;\n\nAMPEREQUAL    : '&=' ;\n\nCIRCUMFLEXEQUAL    : '^=' ;\n\nLEFTSHIFTEQUAL    : '<<=' ;\n\nRIGHTSHIFTEQUAL    : '>>=' ;\n\nDOUBLESTAREQUAL    : '**=' ;\n\nDOUBLESLASHEQUAL    : '//=' ;\n\nDOT : '.' ;\n\nAT : '@' ;\n\nAND : 'and' ;\n\nOR : 'or' ;\n\nNOT : 'not' ;\n\nFLOAT\n    :   '.' DIGITS (Exponent)?\n    |   DIGITS '.' Exponent\n    |   DIGITS ('.' (DIGITS (Exponent)?)? | Exponent)\n    ;\n\nLONGINT\n    :   INT ('l'|'L')\n    ;\n\nfragment\nExponent\n    :    ('e' | 'E') ( '+' | '-' )? DIGITS\n    ;\n\nINT :   // Hex\n        '0' ('x' | 'X') ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+\n    |   // Octal\n        '0' ('o' | 'O') ( '0' .. '7' )*\n    |   '0'  ( '0' .. '7' )*\n    |   // Binary\n        '0' ('b' | 'B') ( '0' .. '1' )*\n    |   // Decimal\n        '1'..'9' DIGITS*\n;\n\nCOMPLEX\n    :   DIGITS+ ('j'|'J')\n    |   FLOAT ('j'|'J')\n    ;\n\nfragment\nDIGITS : ( '0' .. '9' )+ ;\n\nNAME:    ( 'a' .. 'z' | 'A' .. 'Z' | '_')\n        ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*\n    ;\n\n/** Match various string types.  Note that greedy=false implies '''\n *  should make us exit loop not continue.\n */\nSTRING\n    :   ('r'|'u'|'b'|'ur'|'br'|'R'|'U'|'B'|'UR'|'BR'|'uR'|'Ur'|'Br'|'bR')?\n        (   '\\'\\'\\'' (options {greedy=false;}:TRIAPOS)* '\\'\\'\\''\n        |   '\"\"\"' (options {greedy=false;}:TRIQUOTE)* '\"\"\"'\n        |   '\"' (ESC|~('\\\\'|'\\n'|'\"'))* '\"'\n        |   '\\'' (ESC|~('\\\\'|'\\n'|'\\''))* '\\''\n        ) {\n           if (state.tokenStartLine != input.getLine()) {\n               state.tokenStartLine = input.getLine();\n               state.tokenStartCharPositionInLine = -2;\n           }\n        }\n    ;\n\n/** the two '\"'? cause a warning -- is there a way to avoid that? */\nfragment\nTRIQUOTE\n    : '\"'? '\"'? (ESC|~('\\\\'|'\"'))+\n    ;\n\n/** the two '\\''? cause a warning -- is there a way to avoid that? */\nfragment\nTRIAPOS\n    : '\\''? '\\''? (ESC|~('\\\\'|'\\''))+\n    ;\n\nfragment\nESC\n    :    '\\\\' .\n    ;\n\n/** Consume a newline and any whitespace at start of next line\n *  unless the next line contains only white space, in that case\n *  emit a newline.\n */\nCONTINUED_LINE\n    :    '\\\\' ('\\r')? '\\n' (' '|'\\t')*  { $channel=HIDDEN; }\n         ( COMMENT\n         | nl=NEWLINE\n           {\n               emit(new CommonToken(NEWLINE,nl.getText()));\n           }\n         |\n         ) {\n               if (input.LA(1) == -1) {\n                   throw new ParseException(\"unexpected character after line continuation character\");\n               }\n           }\n    ;\n\n/** Treat a sequence of blank lines as a single blank line.  If\n *  nested within a (..), {..}, or [..], then ignore newlines.\n *  If the first newline starts in column one, they are to be ignored.\n *\n *  Frank Wierzbicki added: Also ignore FORMFEEDS (\\u000C).\n */\nNEWLINE\n@init {\n    int newlines = 0;\n}\n    :   (('\\u000C')?('\\r')? '\\n' {newlines++; } )+ {\n         if ( startPos==0 || implicitLineJoiningLevel>0 )\n            $channel=HIDDEN;\n        }\n    ;\n\nWS  :    {startPos>0}?=> (' '|'\\t'|'\\u000C')+ {$channel=HIDDEN;}\n    ;\n\n/** Grab everything before a real symbol.  Then if newline, kill it\n *  as this is a blank line.  If whitespace followed by comment, kill it\n *  as it's a comment on a line by itself.\n *\n *  Ignore leading whitespace when nested in [..], (..), {..}.\n */\nLEADING_WS\n@init {\n    int spaces = 0;\n    int newlines = 0;\n}\n    :   {startPos==0}?=>\n        (   {implicitLineJoiningLevel>0}? ( ' ' | '\\t' )+ {$channel=HIDDEN;}\n        |    (     ' '  { spaces++; }\n             |    '\\t' { spaces += 8; spaces -= (spaces \\% 8); }\n             )+\n             ( ('\\r')? '\\n' {newlines++; }\n             )* {\n                   if (input.LA(1) != -1 || newlines == 0) {\n                       // make a string of n spaces where n is column number - 1\n                       char[] indentation = new char[spaces];\n                       for (int i=0; i<spaces; i++) {\n                           indentation[i] = ' ';\n                       }\n                       CommonToken c = new CommonToken(LEADING_WS,new String(indentation));\n                       c.setLine(input.getLine());\n                       c.setCharPositionInLine(input.getCharPositionInLine());\n                       c.setStartIndex(input.index() - 1);\n                       c.setStopIndex(input.index() - 1);\n                       emit(c);\n                       // kill trailing newline if present and then ignore\n                       if (newlines != 0) {\n                           if (state.token!=null) {\n                               state.token.setChannel(HIDDEN);\n                           } else {\n                               $channel=HIDDEN;\n                           }\n                       }\n                   } else if (this.single && newlines == 1) {\n                       // This is here for this case in interactive mode:\n                       //\n                       // def foo():\n                       //   print 1\n                       //   <spaces but no code>\n                       //\n                       // The above would complete in interactive mode instead\n                       // of giving ... to wait for more input.\n                       //\n                       throw new ParseException(\"Trailing space in single mode.\");\n                   } else {\n                       // make a string of n newlines\n                       char[] nls = new char[newlines];\n                       for (int i=0; i<newlines; i++) {\n                           nls[i] = '\\n';\n                       }\n                       CommonToken c = new CommonToken(NEWLINE,new String(nls));\n                       c.setLine(input.getLine());\n                       c.setCharPositionInLine(input.getCharPositionInLine());\n                       c.setStartIndex(input.index() - 1);\n                       c.setStopIndex(input.index() - 1);\n                       emit(c);\n                   }\n                }\n        )\n    ;\n\n/** Comments not on line by themselves are turned into newlines.\n\n    b = a # end of line comment\n\n    or\n\n    a = [1, # weird\n         2]\n\n    This rule is invoked directly by nextToken when the comment is in\n    first column or when comment is on end of nonwhitespace line.\n\n    Only match \\n here if we didn't start on left edge; let NEWLINE return that.\n    Kill if newlines if we live on a line by ourselves\n\n    Consume any leading whitespace if it starts on left edge.\n */\nCOMMENT\n@init {\n    $channel=HIDDEN;\n}\n    :    {startPos==0}?=> (' '|'\\t')* '#' (~'\\n')* '\\n'+\n    |    '#' (~'\\n')* // let NEWLINE handle \\n unless char pos==0 for '#'\n    ;\n\n","markers":{"markers":{"1":{"id":1,"range":[[170,20],[170,33]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":8,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/zwei/Workspace/jython/grammar/Python.g","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e1b258d38afc6dfb051557b1dfd8ac8270a163a8","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrap":false,"editorWidthInChars":163,"scrollTop":2982,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/zwei/Workspace/jython/grammar/Python.g","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/zwei/Workspace/jython/grammar/Python.g","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["print","printFunction"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/zwei/Workspace/jython/grammar/Python.g":1401232382388},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":78712},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/zwei/Workspace/jython/grammar/Python.g","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}